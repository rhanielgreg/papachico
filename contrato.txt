use anchor_lang::prelude::*;
use anchor_spl::{
    token::{self, Token, TokenAccount, Mint, Transfer, Burn, MintTo, SetAuthority, InitializeMint},
    associated_token::AssociatedToken
};
use spl_token::instruction::AuthorityType;

declare_id!("AGQXGs8ibyWAYszUvx3s9cR69X3ewMLgLdMeXokphVDS");

#[error_code]
pub enum ErrorCode {
    #[msg("Unauthorized access")]
    Unauthorized,
    #[msg("Account is frozen")]
    AccountFrozen,
    #[msg("Cliff period not over")]
    CliffPeriodNotOver,
    #[msg("Nothing to claim")]
    NothingToClaim,
    #[msg("Invalid tax rate")]
    InvalidTaxRate,
    #[msg("Invalid amount")]
    InvalidAmount,
    #[msg("Whitelist not initialized")]
    WhitelistNotInitialized,
}

#[program]
pub mod papa_chico_token {
    use super::*;

    // Eventos para indexação
    #[event]
    pub struct TransferWithTaxEvent {
        pub from: Pubkey,
        pub to: Pubkey,
        pub amount: u64,
        pub tax_amount: u64,
        pub burn_amount: u64,
        pub net_amount: u64,
        pub is_buy: bool,
        pub timestamp: i64,
    }

    #[event]
    pub struct WhitelistUpdate {
        pub address: Pubkey,
        pub added: bool,
        pub timestamp: i64,
    }

    // Inicializa o token com todas as alocações
    pub fn initialize(
        ctx: Context<Initialize>,
        decimals: u8,
        dex_program: Pubkey,
        tax_wallet: Pubkey,
    ) -> Result<()> {
        require!(decimals <= 9, ErrorCode::InvalidAmount);
        
        // Inicializa o mint via CPI
        token::initialize_mint(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                InitializeMint {
                    mint: ctx.accounts.mint.to_account_info(),
                    rent: ctx.accounts.rent.to_account_info(),
                },
            ),
            decimals,
            &ctx.accounts.admin.key(),
            Some(&ctx.accounts.admin.key()), // freeze authority temporária
        )?;

        // Inicializa a configuração
        let config = &mut ctx.accounts.config;
        config.admin = ctx.accounts.admin.key();
        config.dex_program = dex_program;
        config.tax_wallet = tax_wallet;
        config.mint_finalized = false;
        config.buy_tax_rate = 100; // 1%
        config.sell_tax_rate = 250; // 2.5%
        config.burn_rate = 100; // 1%

        // Distribuição total (100%)
        let total_supply = 500_000_000_000 * 10u64.pow(decimals as u32); // 500B
        
        // 1. Queima inicial (20%)
        let burn_amount = total_supply * 20 / 100;
        token::mint_to(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                MintTo {
                    mint: ctx.accounts.mint.to_account_info(),
                    to: ctx.accounts.distribution_pool.to_account_info(),
                    authority: ctx.accounts.admin.to_account_info(),
                },
            ),
            burn_amount,
        )?;
        token::burn(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                Burn {
                    mint: ctx.accounts.mint.to_account_info(),
                    from: ctx.accounts.distribution_pool.to_account_info(),
                    authority: ctx.accounts.admin.to_account_info(),
                },
            ),
            burn_amount,
        )?;

        // 2. Distribuições específicas (55%)
        token::mint_to(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                MintTo {
                    mint: ctx.accounts.mint.to_account_info(),
                    to: ctx.accounts.liquidity_pool.to_account_info(),
                    authority: ctx.accounts.admin.to_account_info(),
                },
            ),
            total_supply * 40 / 100, // 40% liquidez
        )?;

        token::mint_to(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                MintTo {
                    mint: ctx.accounts.mint.to_account_info(),
                    to: ctx.accounts.dev_wallet.to_account_info(),
                    authority: ctx.accounts.admin.to_account_info(),
                },
            ),
            total_supply * 10 / 100, // 10% desenvolvimento
        )?;

        // 3. Time com vesting (5%)
        token::mint_to(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                MintTo {
                    mint: ctx.accounts.mint.to_account_info(),
                    to: ctx.accounts.team_vesting_vault.to_account_info(),
                    authority: ctx.accounts.admin.to_account_info(),
                },
            ),
            total_supply * 5 / 100,
        )?;

        // 4. Reserva administrativa (25%) fica no distribution_pool
        token::mint_to(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                MintTo {
                    mint: ctx.accounts.mint.to_account_info(),
                    to: ctx.accounts.distribution_pool.to_account_info(),
                    authority: ctx.accounts.admin.to_account_info(),
                },
            ),
            total_supply * 25 / 100,
        )?;

        Ok(())
    }

    // Configura o vesting para um membro do time
    pub fn initialize_team_vesting(
        ctx: Context<InitializeTeamVesting>,
        beneficiary: Pubkey,
        amount: u64,
    ) -> Result<()> {
        require!(ctx.accounts.admin.key() == ctx.accounts.config.admin, ErrorCode::Unauthorized);
        require!(amount > 0, ErrorCode::InvalidAmount);
        
        let vesting = &mut ctx.accounts.vesting_schedule;
        vesting.beneficiary = beneficiary;
        vesting.total_amount = amount;
        vesting.claimed_amount = 0;
        vesting.start_date = Clock::get()?.unix_timestamp;
        vesting.cliff_duration = 120 * 24 * 60 * 60; // 4 meses em segundos
        vesting.release_period = 7 * 24 * 60 * 60; // 1 semana em segundos
        vesting.admin = ctx.accounts.admin.key();

        Ok(())
    }

    // Claim de tokens do vesting
    pub fn claim_vesting(ctx: Context<ClaimVesting>) -> Result<()> {
        let vesting = &mut ctx.accounts.vesting_schedule;
        let clock = Clock::get()?;
        
        require!(
            vesting.beneficiary == ctx.accounts.beneficiary.key(),
            ErrorCode::Unauthorized
        );

        let cliff_end = vesting.start_date + vesting.cliff_duration;
        require!(clock.unix_timestamp >= cliff_end, ErrorCode::CliffPeriodNotOver);
        
        let weeks_since_cliff = (clock.unix_timestamp - cliff_end) / vesting.release_period;
        let release_amount = vesting.total_amount / 4; // 25% por período
        let total_available = std::cmp::min(
            release_amount * (weeks_since_cliff as u64 + 1),
            vesting.total_amount
        );
        
        let claimable = total_available - vesting.claimed_amount;
        require!(claimable > 0, ErrorCode::NothingToClaim);
        
        token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                Transfer {
                    from: ctx.accounts.vesting_vault.to_account_info(),
                    to: ctx.accounts.recipient.to_account_info(),
                    authority: ctx.accounts.vesting_signer.to_account_info(),
                },
            ),
            claimable,
        )?;
        
        vesting.claimed_amount += claimable;
        Ok(())
    }

    // Atualiza a carteira de taxas
    pub fn update_tax_wallet(ctx: Context<UpdateTaxWallet>, new_tax_wallet: Pubkey) -> Result<()> {
        require!(ctx.accounts.admin.key() == ctx.accounts.config.admin, ErrorCode::Unauthorized);
        ctx.accounts.config.tax_wallet = new_tax_wallet;
        Ok(())
    }

    // Adiciona endereço à whitelist via PDA (escalável)
    pub fn add_to_whitelist(ctx: Context<UpdateWhitelist>) -> Result<()> {
        require!(ctx.accounts.admin.key() == ctx.accounts.config.admin, ErrorCode::Unauthorized);
        
        let whitelist_account = &mut ctx.accounts.whitelist_account;
        whitelist_account.address = ctx.accounts.address_to_whitelist.key();
        whitelist_account.is_whitelisted = true;

        emit!(WhitelistUpdate {
            address: ctx.accounts.address_to_whitelist.key(),
            added: true,
            timestamp: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }

    // Remove endereço da whitelist
    pub fn remove_from_whitelist(ctx: Context<UpdateWhitelist>) -> Result<()> {
        require!(ctx.accounts.admin.key() == ctx.accounts.config.admin, ErrorCode::Unauthorized);
        
        let whitelist_account = &mut ctx.accounts.whitelist_account;
        whitelist_account.is_whitelisted = false;

        emit!(WhitelistUpdate {
            address: ctx.accounts.address_to_whitelist.key(),
            added: false,
            timestamp: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }

    // Transferência com taxas e validação robusta
    pub fn transfer_with_tax(
        ctx: Context<TransferWithTax>,
        amount: u64,
    ) -> Result<()> {
        require!(!ctx.accounts.from.frozen, ErrorCode::AccountFrozen);
        require!(!ctx.accounts.to.frozen, ErrorCode::AccountFrozen);
        require!(amount > 0, ErrorCode::InvalidAmount);

        let config = &ctx.accounts.config;
        let is_buy = ctx.accounts.from.key() == config.dex_program;
        let tax_rate = if is_buy { config.buy_tax_rate } else { config.sell_tax_rate };
        
        let tax_amount = (amount * tax_rate as u64) / 10000;
        let burn_amount = (amount * config.burn_rate as u64) / 10000;
        let net_amount = amount - tax_amount - burn_amount;

        // Transferência principal
        token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                Transfer {
                    from: ctx.accounts.from.to_account_info(),
                    to: ctx.accounts.to.to_account_info(),
                    authority: ctx.accounts.authority.to_account_info(),
                },
            ),
            net_amount,
        )?;

        // Transferência da taxa
        if tax_amount > 0 {
            token::transfer(
                CpiContext::new(
                    ctx.accounts.token_program.to_account_info(),
                    Transfer {
                        from: ctx.accounts.from.to_account_info(),
                        to: ctx.accounts.tax_wallet.to_account_info(),
                        authority: ctx.accounts.authority.to_account_info(),
                    },
                ),
                tax_amount,
            )?;
        }

        // Queima de tokens
        if burn_amount > 0 {
            token::burn(
                CpiContext::new(
                    ctx.accounts.token_program.to_account_info(),
                    Burn {
                        mint: ctx.accounts.mint.to_account_info(),
                        from: ctx.accounts.from.to_account_info(),
                        authority: ctx.accounts.authority.to_account_info(),
                    },
                ),
                burn_amount,
            )?;
        }

        emit!(TransferWithTaxEvent {
            from: ctx.accounts.from.key(),
            to: ctx.accounts.to.key(),
            amount,
            tax_amount,
            burn_amount,
            net_amount,
            is_buy,
            timestamp: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub admin: Signer<'info>,
    
    #[account(
        init,
        payer = admin,
        space = 8 + Config::LEN
    )]
    pub config: Account<'info, Config>,
    
    #[account(
        init,
        payer = admin,
        mint::decimals = 9,
        mint::authority = admin,
    )]
    pub mint: Account<'info, Mint>,
    
    #[account(mut)]
    pub distribution_pool: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub liquidity_pool: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub dev_wallet: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub team_vesting_vault: Account<'info, TokenAccount>,
    
    pub token_program: Program<'info, Token>,
    pub rent: Sysvar<'info, Rent>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct InitializeTeamVesting<'info> {
    #[account(mut)]
    pub admin: Signer<'info>,
    
    #[account(mut)]
    pub config: Account<'info, Config>,
    
    #[account(
        init,
        payer = admin,
        space = 8 + VestingSchedule::LEN
    )]
    pub vesting_schedule: Account<'info, VestingSchedule>,
    
    #[account(mut)]
    pub vesting_vault: Account<'info, TokenAccount>,
    
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct ClaimVesting<'info> {
    #[account(mut)]
    pub beneficiary: Signer<'info>,
    
    #[account(mut)]
    pub vesting_schedule: Account<'info, VestingSchedule>,
    
    #[account(mut)]
    pub vesting_vault: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub recipient: Account<'info, TokenAccount>,
    
    /// CHECK: This is the vesting PDA
    #[account(
        seeds = [b"vesting", vesting_schedule.key().as_ref()],
        bump
    )]
    pub vesting_signer: UncheckedAccount<'info>,
    
    pub token_program: Program<'info, Token>,
}

#[derive(Accounts)]
pub struct UpdateTaxWallet<'info> {
    #[account(mut)]
    pub admin: Signer<'info>,
    
    #[account(mut)]
    pub config: Account<'info, Config>,
}

#[derive(Accounts)]
pub struct UpdateWhitelist<'info> {
    #[account(mut)]
    pub admin: Signer<'info>,
    
    #[account(mut)]
    pub config: Account<'info, Config>,
    
    #[account(
        init_if_needed,
        payer = admin,
        space = 8 + WhitelistEntry::LEN
    )]
    pub whitelist_account: Account<'info, WhitelistEntry>,
    
    /// CHECK: This is the address to be whitelisted
    pub address_to_whitelist: UncheckedAccount<'info>,
    
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct TransferWithTax<'info> {
    #[account(mut)]
    pub from: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub to: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub tax_wallet: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub mint: Account<'info, Mint>,
    
    pub config: Account<'info, Config>,
    
    /// CHECK: This is the authority that can sign for the from account
    pub authority: UncheckedAccount<'info>,
    
    pub token_program: Program<'info, Token>,
}

#[account]
pub struct Config {
    pub admin: Pubkey,
    pub dex_program: Pubkey,
    pub tax_wallet: Pubkey,
    pub mint_finalized: bool,
    pub buy_tax_rate: u16,  // em basis points (1% = 100)
    pub sell_tax_rate: u16, // em basis points (2.5% = 250)
    pub burn_rate: u16,     // em basis points (1% = 100)
}

impl Config {
    pub const LEN: usize = 32 + 32 + 32 + 1 + 2 + 2 + 2;
}

#[account]
pub struct VestingSchedule {
    pub beneficiary: Pubkey,
    pub total_amount: u64,
    pub claimed_amount: u64,
    pub start_date: i64,
    pub cliff_duration: i64,
    pub release_period: i64,
    pub admin: Pubkey,
}

impl VestingSchedule {
    pub const LEN: usize = 32 + 8 + 8 + 8 + 8 + 8 + 32;
}

#[account]
pub struct WhitelistEntry {
    pub address: Pubkey,
    pub is_whitelisted: bool,
}

impl WhitelistEntry {
    pub const LEN: usize = 32 + 1;
}